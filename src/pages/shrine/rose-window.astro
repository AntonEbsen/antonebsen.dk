
---
import '@styles/styles.css';
---

<!DOCTYPE html>
<html lang="da">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rosace | Rosevinduet</title>
    <meta name="robots" content="noindex, nofollow">
    
    <!-- Fonts -->
    <link rel="icon" type="image/svg+xml" href="/assets/favicon-cross.svg">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&family=Playfair+Display:ital,wght@0,400;0,700;1,400&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css">
    
    <style>
        body { font-family: 'Cinzel', serif; }
        .text-body { font-family: 'Playfair Display', serif; }

        /* Dust Motes Animation */
        @keyframes floating {
            0% { transform: translateY(0) translateX(0); opacity: 0; }
            50% { opacity: 0.8; }
            100% { transform: translateY(-100px) translateX(20px); opacity: 0; }
        }
        .mote {
            position: absolute;
            background: rgba(255, 255, 255, 0.4);
            border-radius: 50%;
            pointer-events: none;
            animation: floating 10s infinite linear;
        }

        .window-rotate {
            animation: rotateFull 240s linear infinite;
        }
        @keyframes rotateFull {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }
    </style>
</head>
<body class="bg-[#020202] text-gray-300 min-h-screen flex flex-col items-center justify-center overflow-hidden relative selection:bg-purple-500/30">

    <!-- Nav -->
    <nav class="fixed top-8 left-8 z-50">
        <a href="/shrine" class="text-white/50 hover:text-white transition-colors text-xl flex items-center gap-2">
            <i class="fa-solid fa-arrow-left"></i>
            <span class="text-xs uppercase tracking-widest hidden md:inline">Forlad Lyset</span>
        </a>
    </nav>
    
    <!-- God Ray Overlay (Controlled by JS) -->
    <div id="god-ray" class="fixed inset-0 pointer-events-none z-20 mix-blend-screen opacity-0 transition-opacity duration-1000">
        <div class="absolute inset-0 bg-gradient-to-b from-transparent via-white/5 to-transparent transform rotate-45 origin-top-left" style="filter: blur(100px);"></div>
    </div>

    <!-- MAIN WINDOW CONTAINER -->
    <div class="relative z-10 w-[80vw] h-[80vw] md:w-[60vh] md:h-[60vh] flex items-center justify-center">
        
        <!-- The Window SVG -->
        <svg viewBox="0 0 1000 1000" class="w-full h-full drop-shadow-[0_0_100px_rgba(100,0,255,0.2)] window-rotate" id="rose-svg">
            <defs>
                <filter id="glow">
                    <feGaussianBlur stdDeviation="5" result="coloredBlur"/>
                    <feMerge>
                        <feMergeNode in="coloredBlur"/>
                        <feMergeNode in="SourceGraphic"/>
                    </feMerge>
                </filter>
            </defs>
            <!-- Generated Segments -->
        </svg>

        <!-- Center Hub -->
        <div class="absolute inset-0 flex items-center justify-center pointer-events-none">
            <div class="w-12 h-12 bg-black rounded-full border-4 border-[#222] shadow-xl z-20"></div>
        </div>

    </div>

    <!-- Instructions / Title -->
    <div class="absolute bottom-12 text-center z-30 pointer-events-none mix-blend-difference">
        <h1 class="text-2xl md:text-3xl text-white/80 font-serif tracking-widest">Lux Mundi</h1>
        <p class="text-[10px] uppercase text-white/50 tracking-[0.3em] mt-2">Bev√¶g lyset. Se farverne.</p>
    </div>

    <!-- Dust Particle Generator -->
    <div id="dust-container" class="fixed inset-0 pointer-events-none z-20"></div>

    <script>
        const svg = document.getElementById('rose-svg');
        const dustContainer = document.getElementById('dust-container');
        const godRay = document.getElementById('god-ray');
        
        // --- 1. GENERATE ROSE WINDOW ---
        function generateRose() {
            if(!svg) return;
            
            // Outer Ring
            const outerRadius = 480;
            const innerRadius = 100;
            const layers = 3;
            
            // Groups for radial symmetry
            // Layer 1 (Outer) - 12 Segments
            createRing(12, 480, 300, ["#4a0e4e", "#311b92", "#1a237e"]); // Purples/Blues
            
            // Layer 2 (Middle) - 24 Segments
            createRing(24, 300, 150, ["#b71c1c", "#880e4f", "#e65100"]); // Reds/Oranges
            
            // Layer 3 (Inner) - 12 Segments
            createRing(12, 150, 50, ["#ffd600", "#ffca28", "#fff176"]); // Golds/Yellows
        }

        function createRing(segments: number, rOuter: number, rInner: number, palette: string[]) {
            const angleStep = 360 / segments;
            
            for(let i=0; i<segments; i++) {
                const startAngle = i * angleStep;
                const endAngle = (i + 1) * angleStep;
                
                // SVG Path Math
                // Convert polar to cartesian
                const p1 = polarToCartesian(500, 500, rOuter, startAngle);
                const p2 = polarToCartesian(500, 500, rOuter, endAngle);
                const p3 = polarToCartesian(500, 500, rInner, endAngle);
                const p4 = polarToCartesian(500, 500, rInner, startAngle);
                
                const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
                const d = `
                    M ${p1.x} ${p1.y}
                    A ${rOuter} ${rOuter} 0 0 1 ${p2.x} ${p2.y}
                    L ${p3.x} ${p3.y}
                    A ${rInner} ${rInner} 0 0 0 ${p4.x} ${p4.y}
                    Z
                `;
                
                path.setAttribute("d", d);
                // Fill
                const color = palette[i % palette.length];
                path.setAttribute("fill", color);
                path.setAttribute("stroke", "#111");
                path.setAttribute("stroke-width", "4");
                path.setAttribute("fill-opacity", "0.7");
                
                // Add interaction class
                path.classList.add("glass-segment");
                path.style.transition = "fill-opacity 0.2s, filter 0.2s";
                
                svg?.appendChild(path);
            }
        }

        function polarToCartesian(centerX: number, centerY: number, radius: number, angleInDegrees: number) {
            const angleInRadians = (angleInDegrees - 90) * Math.PI / 180.0;
            return {
                x: centerX + (radius * Math.cos(angleInRadians)),
                y: centerY + (radius * Math.sin(angleInRadians))
            };
        }

        generateRose();

        // --- 2. INTERACTION (God Rays) ---
        document.addEventListener('mousemove', (e) => {
            const x = e.clientX;
            const y = e.clientY;
            
            // Update God Ray visual
            if(godRay) {
                 godRay.style.opacity = '0.4';
                 const angle = (x / window.innerWidth) * 45 - 22.5; // Slight tilt
                 const gradStart = `rgba(255,255,255,${0.1 + (y/window.innerHeight)*0.2})`;
                 
                 // We simulate lighting up segments near cursor projected 
                 // Actually easier to just light up segments based on angle from center of screen
            }
            
            // Light up SVG segments
            const cx = window.innerWidth / 2;
            const cy = window.innerHeight / 2;
            const angle = Math.atan2(y - cy, x - cx) * 180 / Math.PI; // Mouse angle
            
            // Normalize angle to 0-360
            let normAngle = angle + 90; 
            if(normAngle < 0) normAngle += 360;
            
            // Highlight logic approx (complex to map exactly to rotating SVG, so let's just use proximity generally)
            // Let's just boost opacity of ALL segments based on distance from center?
            // Or change filter based on mouse X
            
            const intensity = 1 - (Math.abs(x - cx) / cx); // Higher in center horizontal
            
            // Actually, let's just make the window colors vibrant when mouse moves
             document.querySelectorAll('.glass-segment').forEach((el) => {
                 (el as SVGElement).setAttribute('fill-opacity', (0.7 + intensity * 0.3).toString());
                 if(Math.random() > 0.95) {
                      (el as SVGElement).setAttribute('filter', 'url(#glow)');
                      setTimeout(() => (el as SVGElement).removeAttribute('filter'), 200);
                 }
             });
        });

        // --- 3. DUST PARTICLES ---
        function createDust() {
            if(!dustContainer) return;
            const mote = document.createElement('div');
            mote.className = "mote";
            
            // Random properties
            const size = Math.random() * 3 + 1;
            mote.style.width = `${size}px`;
            mote.style.height = `${size}px`;
            mote.style.left = `${Math.random() * 100}vw`;
            mote.style.top = `${Math.random() * 100}vh`;
            mote.style.animationDuration = `${10 + Math.random() * 20}s`;
            
            dustContainer.appendChild(mote);
            
            // Cleanup
            setTimeout(() => mote.remove(), 30000);
        }
        
        // Init dust
        for(let i=0; i<30; i++) createDust();
        setInterval(createDust, 1000);

    </script>
</body>
</html>
