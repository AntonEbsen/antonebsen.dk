import fs from 'fs/promises';
import path from 'path';
import pdf from 'pdf-parse';

// ...

if (file.endsWith('.pdf')) {
    console.log(`   - Reading PDF: ${file}`);
    const buffer = await fs.readFile(filePath);
    try {
        const data = await pdf(buffer);
        // Clean up text slightly to save space
        const cleanText = data.text.replace(/\n\s*\n/g, '\n').trim();
        allText += `\n--- START DOCUMENT: ${file} ---\n${cleanText}\n--- END DOCUMENT ---\n`;
    } catch (pdfError) {
        console.error(`   ❌ Failed to parse PDF ${file}:`, pdfError.message);
    }
}
else if (file.endsWith('.txt') || file.endsWith('.md')) {
    console.log(`   - Reading Text: ${file}`);
    const text = await fs.readFile(filePath, 'utf-8');
    allText += `\n--- START DOCUMENT: ${file} ---\n${text.trim()}\n--- END DOCUMENT ---\n`;
}
        } catch (err) {
    console.error(`❌ Error processing ${file}:`, err.message);
}
    }

// Escape backticks and standard JS escaping for the string content
const escapedText = allText.replace(/\\/g, '\\\\').replace(/`/g, '\\`').replace(/\${/g, '\\${');

// LIMIT SIZE TO PREVENT BUILD HANGS (Temporary Fix)
const limitedText = escapedText.length > 50000 ? escapedText.substring(0, 50000) + "\n[TRUNCATED]" : escapedText;

const fileContent = `// Auto-generated by scripts/process-docs.mjs
// Do not edit manually.
export const ragContent = \`${limitedText}\`;
`;

await fs.writeFile(outputFile, fileContent);
console.log(`✅ RAG Content generated at ${outputFile} (Truncated to ${limitedText.length} chars)`);
}

processDocs();
