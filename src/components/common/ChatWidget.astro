---
import { getLangFromUrl } from '@i18n/utils';

const lang = getLangFromUrl(Astro.url);

const t_obj = {
  da: {
    title: "Anton's AI",
    online: "Online",
    intro: "Hej! Jeg er Antons AI-assistent. Sp√∏rg mig om hans erfaring, eller bed mig om at <strong>vise en graf</strong> over hans kompetencer!",
    placeholder: "Pr√∏v f.eks: 'Vis mig en graf over dine skills'...",
    disclaimer: "Drevet af AI ¬∑ Kan lave fejl",
    error: "Beklager, jeg st√∏dte p√• en fejl.",
    configError: "Konfigurationsfejl: Mangler API-n√∏gle.",
    serverError: "Beklager, jeg kan ikke f√• forbindelse til serveren.",
    prompts: ["üìä Vis mig en graf over Antons skills", "üíº Opsummer Antons erfaring", "üöÄ Hvorfor skal jeg ans√¶tte Anton?"]
  },
  en: {
    title: "Anton's AI",
    online: "Online",
    intro: "Hi! I'm Anton's AI assistant. Ask me about his experience, or ask me to <strong>graph his skills</strong>!",
    placeholder: "Try: 'Show me a graph of your skills'...",
    disclaimer: "Powered by AI ¬∑ May produce inaccuracies",
    error: "Sorry, I encountered an error.",
    configError: "Configuration Error: Missing API Key.",
    serverError: "Sorry, I'm having trouble reaching the server.",
    prompts: ["üìä Graph Anton's skills", "üíº Summarize Anton's experience", "üöÄ Why should I hire Anton?"]
  },
  de: {
    title: "Antons KI",
    online: "Online",
    intro: "Hallo! Ich bin Antons KI-Assistent. Fragen Sie mich nach seiner Erfahrung oder lassen Sie sich seine <strong>Kenntnisse grafisch anzeigen</strong>!",
    placeholder: "Versuchen Sie: 'Zeige mir eine Grafik deiner Skills'...",
    disclaimer: "Unterst√ºtzt durch KI ¬∑ Kann Fehler machen",
    error: "Entschuldigung, es ist ein Fehler aufgetreten.",
    configError: "Konfigurationsfehler: API-Schl√ºssel fehlt.",
    serverError: "Entschuldigung, ich kann keine Verbindung zum Server herstellen.",
    prompts: ["üìä Zeige Grafiken zu Antons Skills", "üíº Zusammenfassung von Antons Erfahrung", "üöÄ Warum sollte ich Anton einstellen?"]
  }
};

const t = (t_obj as any)[lang] || t_obj.da;
---

<script is:inline src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
<script is:inline>
    // Initialize PDF.js worker if not already done
    if (window.pdfjsLib && !window.pdfjsLib.GlobalWorkerOptions.workerSrc) {
        window.pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
    }
</script>

<div id="chat-widget" class="fixed bottom-4 right-4 md:bottom-6 md:right-6 z-50 flex flex-col items-end pointer-events-none" data-lang={lang}>
  
  <!-- Chat Window -->
  <div id="chat-window" class="w-[calc(100vw-2rem)] md:w-[350px] h-[500px] max-h-[75vh] mb-4 bg-glass border border-glass-border rounded-xl shadow-2xl flex flex-col transform translate-y-10 opacity-0 pointer-events-auto transition-all duration-300 origin-bottom-right hidden">
    
    <!-- Header -->
    <div id="chat-header" class="p-4 border-b border-glass-border flex justify-between items-center bg-accent/5 rounded-t-xl cursor-move select-none">
      <div class="flex items-center gap-3">
        <div class="w-8 h-8 rounded-full bg-accent text-bg flex items-center justify-center">
          <i class="fa-solid fa-robot"></i>
        </div>
        <div>
          <h3 class="font-bold text-sm">{t.title}</h3>
          <p class="text-[10px] text-accent flex items-center gap-1">
            <span class="w-1.5 h-1.5 rounded-full bg-green-500 animate-pulse"></span> {t.online}
          </p>
        </div>
      </div>
      <div class="flex gap-2 items-center">
        <!-- Persona Selector -->
        <div class="relative group mr-1">
            <select id="widget-persona-select" class="appearance-none bg-neutral-900 border border-accent/20 text-white text-[10px] rounded-md py-1 pl-2 pr-6 cursor-pointer hover:bg-neutral-800 transition-colors focus:outline-none">
                <option value="default" class="bg-neutral-900 text-white">Standard</option>
                <option value="recruiter" class="bg-neutral-900 text-white">üíº Recruiter</option>
                <option value="tech" class="bg-neutral-900 text-white">üíª Tech Lead</option>
                <option value="eli5" class="bg-neutral-900 text-white">üë∂ ELI5</option>
            </select>
            <i class="fa-solid fa-chevron-down absolute right-2 top-1/2 -translate-y-1/2 text-[8px] text-accent pointer-events-none"></i>
        </div>

        <a href="/ai-chat" class="text-dim hover:text-accent transition-colors p-1" title={lang==='da' ? "√Öbn stor chat" : "Open full chat"}>
          <i class="fa-solid fa-expand"></i>
        </a>
        <a href="/ai-project" class="text-dim hover:text-accent transition-colors p-1" title={lang==='da' ? "Om denne AI" : "About this AI"}>
          <i class="fa-solid fa-circle-info"></i>
        </a>
        <button id="clear-widget-chat" class="text-dim hover:text-red-400 transition-colors p-1" title={lang==='da' ? "Slet historik" : "Clear history"}>
           <i class="fa-solid fa-trash"></i>
        </button>
        <button id="close-chat" class="text-dim hover:text-white transition-colors p-1">
          <i class="fa-solid fa-xmark"></i>
        </button>
      </div>
    </div>

    <!-- Chat Area -->
  <div id="chat-messages" class="flex-1 overflow-y-auto p-4 space-y-4 scrollbar-thin scrollbar-thumb-white/10 scrollbar-track-transparent relative z-10">
    <!-- Visualizer Overlay -->
    <canvas id="widget-visualizer" class="absolute bottom-0 left-0 w-full h-32 pointer-events-none opacity-0 transition-opacity duration-300 z-0"></canvas>
    
    <div class="flex gap-3 text-sm text-gray-400 border-b border-white/5 pb-4 mb-4">
        <div class="w-6 h-6 rounded-full bg-accent/20 flex-shrink-0 flex items-center justify-center text-[10px] text-accent mt-1">
          <i class="fa-solid fa-robot"></i>
        </div>
        <div class="bg-glass-border/50 p-3 rounded-lg rounded-tl-none max-w-[85%] border border-accent">
          <p set:html={t.intro} />
        </div>
      </div>
      
      <!-- Quick Prompts -->
      <div class="grid grid-cols-1 gap-2 pl-12">
         {t.prompts.map(p => (
           <button class="text-left text-xs bg-white/5 border border-white/10 hover:bg-white/10 hover:border-accent/50 transition-colors rounded-lg p-2 text-dim hover:text-white quick-prompt-btn">
             {p}
           </button>
         ))}
      </div>
      
      <!-- Messages will appear here -->
    </div>

    <!-- Input -->
    <div class="p-3 border-t border-glass-border bg-glass/50 rounded-b-xl">
      <form id="chat-form" class="flex gap-2">
        <input 
          type="text" 
          id="chat-input"
          placeholder={t.placeholder}
          class="flex-1 bg-neutral-900 border border-glass-border rounded-lg px-3 py-2 text-sm text-white focus:outline-none focus:border-accent/50 transition-colors placeholder:text-white/40"
          autocomplete="off"
        />
        <input type="file" id="chat-file" hidden accept=".pdf,.txt,.md,.csv,.jpg,.jpeg,.png,.webp" />
        <button type="button" id="file-btn" class="bg-glass/20 text-dim hover:text-white hover:bg-glass/40 w-9 h-9 rounded-lg flex items-center justify-center transition-all group" title="Upload Document">
            <i class="fa-solid fa-paperclip text-xs group-hover:scale-110 transition-transform"></i>
        </button>
        <button type="button" id="voice-btn" class="bg-glass/20 text-dim hover:text-white hover:bg-glass/40 w-9 h-9 rounded-lg flex items-center justify-center transition-all group relative" title="Speak to Anton (Voice Mode)">
           <i class="fa-solid fa-microphone text-xs group-hover:scale-110 transition-transform"></i>
           <span class="absolute inset-0 rounded-lg border border-red-500 opacity-0 transition-opacity" id="voice-indicator"></span>
        </button>
        <button type="submit" class="bg-accent text-bg w-9 h-9 rounded-lg flex items-center justify-center hover:bg-white transition-colors">
          <i class="fa-solid fa-paper-plane text-xs"></i>
        </button>
      </form>
      <div id="file-display" class="hidden mt-2 px-2 py-1 bg-accent/10 border border-accent/20 rounded flex items-center justify-between text-[10px] text-accent">
          <span class="truncate flex-1 font-mono"><i class="fa-solid fa-file-pdf mr-1"></i><span id="filename"></span></span>
          <button type="button" id="remove-file" class="ml-2 hover:text-white"><i class="fa-solid fa-times"></i></button>
      </div>
      <div class="text-[10px] text-center text-dim/30 mt-2">
        {t.disclaimer}
      </div>
    </div>
  </div>

  <!-- Toggle Button -->
  <button id="chat-toggle" class="pointer-events-auto w-14 h-14 bg-accent text-bg rounded-full shadow-lg shadow-accent/20 flex items-center justify-center hover:bg-white hover:scale-110 transition-all duration-300 group">
    <i class="fa-solid fa-message text-xl group-hover:scale-110 transition-transform"></i>
  </button>

</div>

<script>
  import { AudioVisualizer } from '../../lib/audio-visualizer';
  import { unlockAchievement } from '../../lib/gamification';

  try {

      // Elements
      const widget = document.getElementById('chat-widget');
      const chatWindow = document.getElementById('chat-window');
      const toggle = document.getElementById('chat-toggle');
      const close = document.getElementById('close-chat');
      const form = document.getElementById('chat-form');
      const input = document.getElementById('chat-input');
      const messages = document.getElementById('chat-messages');
      const voiceBtn = document.getElementById('voice-btn');
      const voiceIndicator = document.getElementById('voice-indicator');
      const visualizerCanvas = document.getElementById('widget-visualizer');

      // Concierge Logic
      const currentLang = widget?.getAttribute('data-lang') || 'da';
      const currentPath = window.location.pathname;
      
      const conciergeMessages = {
          '/cv': {
              da: "Har du sp√∏rgsm√•l til min erfaring eller specifikke roller?",
              en: "Do you have questions about my experience or specific roles?"
          },
          '/portfolio': {
              da: "Jeg kan forklare teknologistakken bag disse projekter. Sp√∏rg l√∏s!",
              en: "I can explain the tech stack behind these projects. Ask away!"
          },
          '/blog': {
              da: "L√¶ser du mine tanker? Jeg kan opsummere ethvert blogindl√¶g for dig.",
              en: "Reading my thoughts? I can summarize any post for you."
          },
          '/ai-project': {
              da: "Nysgerrig p√• hvordan jeg arbejder? Sp√∏rg mig om min RAG-arkitektur!",
              en: "Curious about how I work? Ask me about my RAG architecture!"
          }
      };

      try {
          const matchedPath = Object.keys(conciergeMessages).find(path => currentPath.startsWith(path));
          
          if (matchedPath) {
             const msg = conciergeMessages[matchedPath][currentLang];
             const introText = document.querySelector('#chat-messages p');
             if (introText) {
                 introText.textContent = msg;
                 introText.parentElement.classList.add('border-accent', 'border');
             }
          }
      } catch(err) {
          console.error("Concierge Error:", err);
      }

      // UI Logic
      let isOpen = false;
      let wasVoiceInput = false;
      let currentAudio = null;

      function toggleChat() {
        if (!chatWindow || !toggle) return;
        
        isOpen = !isOpen;
        if (isOpen) {
          chatWindow.classList.remove('hidden');
          setTimeout(() => {
            chatWindow.classList.remove('translate-y-10', 'opacity-0');
            toggle.classList.add('scale-0', 'opacity-0');
            toggle.style.display = 'none'; 
          }, 10);
          input?.focus();
        } else {
          chatWindow.classList.add('translate-y-10', 'opacity-0');
          toggle.style.display = 'flex';
          setTimeout(() => {
             toggle.classList.remove('scale-0', 'opacity-0');
          }, 10);
          setTimeout(() => {
            chatWindow.classList.add('hidden');
          }, 300);
        }
      }

      if (toggle) toggle.onclick = toggleChat; // Use onclick to avoid duplicates if re-run
      if (close) close.onclick = toggleChat;

      // File Upload Logic
      const fileInput = document.getElementById('chat-file');
      const fileBtn = document.getElementById('file-btn');
      const fileDisplay = document.getElementById('file-display');
      const fileNameSpan = document.getElementById('filename');
      const removeFileBtn = document.getElementById('remove-file');
      let currentFileContent = null;

      fileBtn?.addEventListener('click', () => fileInput?.click());

      fileInput?.addEventListener('change', async (e) => {
          const file = e.target.files?.[0];
          if (!file) return;

          if(fileDisplay && fileNameSpan) {
              fileDisplay.classList.remove('hidden');
              fileNameSpan.textContent = "Processing..." + file.name;
          }

          try {
              let text = "";
              if (file.type === 'application/pdf') {
                  if(!window.pdfjsLib) throw new Error("PDF.js not loaded");
                  const arrayBuffer = await file.arrayBuffer();
                  const pdf = await window.pdfjsLib.getDocument({ data: arrayBuffer }).promise;
                  for (let i = 1; i <= pdf.numPages; i++) {
                      const page = await pdf.getPage(i);
                      const content = await page.getTextContent();
                      text += content.items.map(item => item.str).join(' ') + "\n";
                  }
                  currentFileContent = `\n\n<<<FILE_CONTENT Start: ${file.name}>>>\n${text}\n<<<FILE_CONTENT End>>>\n`;
              
              } else if (file.type.startsWith('image/')) {
                  // Image Handling
                   const reader = new FileReader();
                   reader.onload = () => {
                       const base64 = reader.result.split(',')[1];
                       currentFileContent = {
                           type: 'image',
                           data: base64,
                           mimeType: file.type,
                           name: file.name
                       };
                   };
                   reader.readAsDataURL(file);
                   if(fileNameSpan) fileNameSpan.textContent = file.name + " (Image Ready)";
                   return; 

              } else {
                  text = await file.text();
                  currentFileContent = `\n\n<<<FILE_CONTENT Start: ${file.name}>>>\n${text}\n<<<FILE_CONTENT End>>>\n`;
              }

              if(fileNameSpan) fileNameSpan.textContent = file.name + " (Ready)";
              
          } catch (err) {
              console.error("File read error:", err);
              if(fileNameSpan) fileNameSpan.textContent = "Error reading file";
              currentFileContent = null;
          }
      });

      removeFileBtn?.addEventListener('click', () => {
          currentFileContent = null;
          if (fileInput) fileInput.value = '';
          fileDisplay?.classList.add('hidden');
      });
      
      // Persona Logic
      const personaSelect = document.getElementById('widget-persona-select');
      if (personaSelect) {
          const savedPersona = localStorage.getItem('anton_ai_persona');
          if (savedPersona) personaSelect.value = savedPersona;
          
          personaSelect.addEventListener('change', (e) => {
              const val = e.target.value;
              localStorage.setItem('anton_ai_persona', val);
              // Option: Announce change in chat? For now, no.
          });
      }

      // Draggable Logic
      const header = document.getElementById('chat-header');
      let isDragging = false;
      let currentX;
      let currentY;
      let initialX;
      let initialY;
      let xOffset = 0;
      let yOffset = 0;

      if (header && chatWindow) {
          header.addEventListener('mousedown', dragStart);
          document.addEventListener('mousemove', drag);
          document.addEventListener('mouseup', dragEnd);
          
          // Touch support
          header.addEventListener('touchstart', dragStart, {passive: false});
          document.addEventListener('touchmove', drag, {passive: false});
          document.addEventListener('touchend', dragEnd);
      }

      function dragStart(e) {
         if (e.target.closest('button') || e.target.closest('a')) return;
         
         if (e.type === "touchstart") {
             initialX = e.touches[0].clientX - xOffset;
             initialY = e.touches[0].clientY - yOffset;
         } else {
             initialX = e.clientX - xOffset;
             initialY = e.clientY - yOffset;
         }

         if (e.target === header || header.contains(e.target)) {
             isDragging = true;
             const rect = chatWindow.getBoundingClientRect();
             
             if (chatWindow.style.position !== 'fixed') {
                 chatWindow.style.position = 'fixed';
                 chatWindow.style.left = rect.left + 'px';
                 chatWindow.style.top = rect.top + 'px';
                 chatWindow.style.marginBottom = '0';
                 chatWindow.style.transform = 'none';
                 
                 initialX = e.clientX || e.touches[0].clientX;
                 initialY = e.clientY || e.touches[0].clientY;
                 
                 xOffset = rect.left;
                 yOffset = rect.top;
             }
         }
      }

      function dragEnd(e) {
         initialX = currentX;
         initialY = currentY;
         isDragging = false;
      }

      function drag(e) {
         if (isDragging) {
             e.preventDefault();
             
             let clientX, clientY;
             if (e.type === "touchmove") {
                 clientX = e.touches[0].clientX;
                 clientY = e.touches[0].clientY;
             } else {
                 clientX = e.clientX;
                 clientY = e.clientY;
             }

             const dx = clientX - initialX;
             const dy = clientY - initialY;
             
             currentX = xOffset + dx;
             currentY = yOffset + dy;

             const rect = chatWindow.getBoundingClientRect();
             const viewportWidth = window.innerWidth;
             const viewportHeight = window.innerHeight;
             
             if (currentX < 0) currentX = 0;
             if (currentX + rect.width > viewportWidth) currentX = viewportWidth - rect.width;
             
             if (currentY < 0) currentY = 0;
             if (currentY + rect.height > viewportHeight) currentY = viewportHeight - rect.height;
             
             chatWindow.style.left = currentX + 'px';
             chatWindow.style.top = currentY + 'px';
         }
      }

      // Voice Logic
      let isRecording = false;
      let isInitializing = false;
      let mediaRecorder = null;
      let audioChunks = [];

      async function startRecording() {
          if (isInitializing || isRecording) return;
          
          isInitializing = true;
          // UI Feedback: Connecting
          voiceBtn?.classList.add('animate-pulse', 'text-accent');
          input.placeholder = "Connecting to ears...";

          try {
              const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
              
              // Connect Mic to Visualizer
              if (visualizerCanvas) visualizerCanvas.classList.remove('opacity-0');
              if (visualizer) visualizer.connectStream(stream);

              const mimeType = MediaRecorder.isTypeSupported('audio/webm;codecs=opus') 
                             ? 'audio/webm;codecs=opus' 
                             : 'audio/webm';
              
              mediaRecorder = new MediaRecorder(stream, { mimeType });
              audioChunks = [];

              mediaRecorder.ondataavailable = (event) => {
                  if (event.data.size > 0) {
                      audioChunks.push(event.data);
                  }
              };

              mediaRecorder.onstop = async () => {
                  // UI Reset
                  if(voiceIndicator) {
                      voiceIndicator.classList.add('opacity-0');
                      voiceIndicator.classList.remove('animate-pulse', 'border-red-500');
                  }
                  if (visualizerCanvas) visualizerCanvas.classList.add('opacity-0');
                  if (visualizer) visualizer.stop();

                  voiceBtn?.classList.remove('text-red-400');
                  isRecording = false;
                  isInitializing = false;

                  // Process Audio
                  const audioBlob = new Blob(audioChunks, { type: mimeType });
                  // Debug: Log blob size
                  console.log(`üé§ Audio recorded: ${audioBlob.size} bytes`);
                  
                  if (audioBlob.size < 1000) {
                      alert("Kunne ikke h√∏re noget (optagelse for kort). Pr√∏v at tale h√∏jere/l√¶ngere.");
                      input.placeholder = t.placeholder;
                      return;
                  }
                  
                  wasVoiceInput = true; // Flag for TTS

                  const formData = new FormData();
                  formData.append('audio', audioBlob, 'recording.webm');

                  // Show thinking state in input
                  const originalPlaceholder = input.placeholder;
                  input.placeholder = "üß† Processing voice...";
                  input.disabled = true;

                  try {
                      const response = await fetch('/api/stt', {
                          method: 'POST',
                          body: formData,
                      });

                      if (!response.ok) throw new Error(`STT failed: ${response.status}`);

                      const data = await response.json();
                      
                      if (data.text) {
                          input.value = (input.value ? input.value + " " : "") + data.text;
                          input.focus();
                      } else {
                         if (data.error) {
                             alert(`Fejl fra server: ${data.error}`);
                         } else {
                             input.placeholder = "Jeg h√∏rte ikke noget...";
                             setTimeout(() => input.placeholder = originalPlaceholder, 2000);
                         }
                      }
                  } catch (err) {
                      console.error("STT Error:", err);
                      // Fallback or error indication
                      input.placeholder = "Fejl ved tolkning...";
                      // alert("Fejl ved tolkning af lyd: " + err.message);
                  } finally {
                      input.disabled = false;
                      if (!input.placeholder.includes("Kunne")) {
                           input.placeholder = originalPlaceholder;
                      }
                  }

                  // Stop all tracks
                  stream.getTracks().forEach(track => track.stop());
              };

              // Start recording
              mediaRecorder.start();
              isRecording = true;
              isInitializing = false;
              
              // UI Update: Listening
              input.placeholder = "Listening... (Tap mic to stop)";
              if(voiceIndicator) {
                  voiceIndicator.classList.remove('opacity-0');
                  voiceIndicator.classList.add('animate-pulse', 'border-red-500');
              }
              voiceBtn?.classList.remove('animate-pulse', 'text-accent'); // Remove connecting state
              voiceBtn?.classList.add('text-red-400');

          } catch (err) {
              console.error("Microphone Access Error:", err);
              isInitializing = false;
              voiceBtn?.classList.remove('animate-pulse', 'text-accent');
              
              let msg = "Ukendt fejl";
              if (err.name === 'NotAllowedError' || err.name === 'PermissionDeniedError') {
                  msg = "Adgang n√¶gtet. Tjek l√•sen i adressebaren.";
              } else {
                  msg = err.message || "Mikrofon fejl";
              }
              alert(`Kunne ikke starte mikrofon: ${msg}`);
              input.placeholder = t.placeholder;
          }
      }

      function stopRecording() {
          if (mediaRecorder && isRecording) {
              mediaRecorder.stop();
              // State update happens in onstop
          }
      }

      voiceBtn?.addEventListener('click', (e) => {
          e.preventDefault(); // Prevent focus quirks
          
          if (isInitializing) return; // Ignore clicks while connecting

          if (isRecording) {
              stopRecording();
          } else {
              startRecording();
          }
      });

      // Quick Prompts Logic
      document.querySelectorAll('.quick-prompt-btn').forEach(btn => {
        btn.addEventListener('click', (e) => {
            const text = e.currentTarget.textContent?.trim();
            if(text && input && form) {
                input.value = text;
                form.dispatchEvent(new Event('submit'));
                e.currentTarget.parentElement?.remove();
            }
        });
      });

      // Submit Logic
      if (form) {
          form.addEventListener('submit', async (e) => {
            e.preventDefault();
            const query = input?.value.trim() || "";
            if (!query && !currentFileContent) return;

            const persona = localStorage.getItem('anton_ai_persona') || 'default';

            addMessage(query || (currentFileContent ? `[Attached: ${fileInput?.files?.[0]?.name}]` : "Empty message"), 'user', false, persona);
            
            let fullPayload = query + (currentFileContent || "");
            
            if (input) input.value = '';
            
            if(currentFileContent) {
                removeFileBtn?.click();
            }

            showTyping();

            const currentLang = document.documentElement.lang || 'da';
            let accumulatedText = "";
        
        try {
              let payload = { message: query, lang: currentLang, persona };
              if (currentFileContent && currentFileContent.type === 'image') {
                  payload.image = { data: currentFileContent.data, mimeType: currentFileContent.mimeType };
                  // Add visual indicator to message history but NOT to payload message if we want clean separation
                  // But for now, let's keep it simple
                  fullPayload += ` [Image: ${currentFileContent.name}]`;
              } else {
                   // Append text content if text file
                   // Note: 'fullPayload' was calculated above as query + (currentFileContent || "")
                   // We need to be careful not to double add
              }
              
              const res = await fetch('/api/chat', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ 
                    message: fullPayload, 
                    lang: currentLang, 
                    persona,
                    image: (currentFileContent && currentFileContent.type === 'image') ? { data: currentFileContent.data, mimeType: currentFileContent.mimeType } : undefined
                })
              });
              
              removeTyping();

              if (!res.ok) {
                 const text = await res.text();
                 let errorMsg = `Server Error (${res.status})`;
                 if (text) {
                     try {
                         const data = JSON.parse(text);
                         errorMsg = data.message || errorMsg;
                     } catch (e) {
                         errorMsg += `: ${text.substring(0, 100)}...`;
                     }
                 } else {
                     errorMsg += ": Empty Response";
                 }
                 
                 addMessage("‚ö†Ô∏è " + errorMsg, 'ai', false, persona);
                 return;
              }

              // Handle Non-Streaming JSON (Legacy Fallback)
              const contentType = res.headers.get('content-type');
              if (contentType && contentType.includes('application/json')) {
                  const data = await res.json();
                  const finalMsg = data.message || data.error || "No response";
                  
                  if (data.error) {
                      addMessage("‚ö†Ô∏è " + data.error, 'ai', false, persona);
                  } else {
                      const msgEl = addMessage(finalMsg, 'ai', true, persona);
                      saveMessageToHistory(finalMsg, 'ai', persona);
                      // Process tags
                      if(msgEl) {
                           const wrapper = msgEl.closest('.ai-content-wrapper');
                           processSpecialTags(finalMsg, wrapper);
                      }
                  }
                  return;
              }

              // Handle Streaming (If any)
              const messageContent = addMessage("", 'ai', true, persona);
              const reader = res.body?.getReader();
              const decoder = new TextDecoder();


              if (reader) {
                  while (true) {
                      const { done, value } = await reader.read();
                      if (done) break;
                      
                      const chunk = decoder.decode(value, { stream: true });
                      accumulatedText += chunk;
                      
                      if (messageContent) {
                          messageContent.innerHTML = formatText(accumulatedText);
                      }
                      const msgs = document.getElementById('chat-messages');
                      if(msgs) msgs.scrollTop = msgs.scrollHeight;
                  }
              }

              saveMessageToHistory(accumulatedText, 'ai', persona);

              if (messageContent) {
                   const wrapper = messageContent.closest('.ai-content-wrapper');
                   processSpecialTags(accumulatedText, wrapper); 
              }

            } catch (err) {
              removeTyping();
              console.error(err);
              addMessage(`‚ö†Ô∏è Connection error: ${err.message || 'Unknown'}`, 'ai');
            }

            // --- VOICE RESPONSE (Level 3) ---
            console.log("üé§ Voice Check | wasVoiceInput:", wasVoiceInput, "Text Length:", accumulatedText?.length);
            
            if (wasVoiceInput) {
                try {
                     const speechText = accumulatedText
                        .replace(/<<<.*?>>>/g, '')
                        .replace(/<[^>]*>/g, '') 
                        .replace(/\*/g, '')
                        .trim();
                     
                     console.log("üé§ Speech Text extracted:", speechText.substring(0, 50) + "...");

                     if (speechText) {
                         // Play Audio
                         await playTextToSpeech(speechText);
                     } else {
                         console.warn("üé§ No speech text found after cleaning.");
                     }
                } catch (e) {
                    console.error("Auto-Speak Error:", e);
                } finally {
                    wasVoiceInput = false; // Reset flag
                }
            }

          }); // End submit listener

         // --- TTS HELPER (Widget) ---


         // --- VISUALIZER ---

         let visualizer = null;
         if (visualizerCanvas) {
             visualizer = new AudioVisualizer(visualizerCanvas, 'rgb(168, 85, 247)'); // Purple for Widget
         }


        async function playTextToSpeech(text) {
            console.log("üîä playTextToSpeech called");
            if (currentAudio) {
                currentAudio.pause();
                currentAudio = null;
            }
            
            // Visual Feedback
            const robotIcon = document.querySelector('#chat-window .fa-robot');
            robotIcon?.classList.add('text-purple-400', 'animate-pulse');
            
            // Show Visualizer
            if (visualizerCanvas) visualizerCanvas.classList.remove('opacity-0');

            try {
                console.log("üîä Fetching TTS from /api/speak...");
                const res = await fetch('/api/speak', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ text })
                });

                if (!res.ok) {
                    const err = await res.text();
                    throw new Error(`TTS Failed (${res.status}): ${err}`);
                }

                const blob = await res.blob();
                const url = URL.createObjectURL(blob);
                currentAudio = new Audio(url);
                
                // Connect to Visualizer
                if (visualizer) visualizer.connectElement(currentAudio);
                
                currentAudio.onended = () => {
                   console.log("üîä Playback ended");
                   robotIcon?.classList.remove('text-purple-400', 'animate-pulse');
                   if (visualizerCanvas) visualizerCanvas.classList.add('opacity-0');
                   if (visualizer) visualizer.stop();
                   // Reset flag so next text message doesn't speak unless voice was used again
                   wasVoiceInput = false; 
                };
                
                console.log("üîä Starting playback...");
                await currentAudio.play();
                if (visualizer) visualizer.start();

            } catch (e) {
                console.error("TTS Playback Error", e);
                robotIcon?.classList.remove('text-purple-400', 'animate-pulse');
                if (visualizerCanvas) visualizerCanvas.classList.add('opacity-0');
            }
        }
        
        // Reset flag on text submit
        form?.addEventListener('submit', () => {
             // If manual submit (not voice), ensure flag is false
             // Use a short timeout because voice logic might submit form programmatically
             setTimeout(() => {
                 if(document.activeElement === input) wasVoiceInput = false;
             }, 100);
        });
      }

      // Helpers
      function formatText(text) {
          return text.replace(/<<<CHART[\s\S]*?CHART>>>/g, '')
                     .replace(/<<<NAVIGATE:.*?>>>/gi, '')
                     .replace(/<<<SUGGESTIONS:.*?>>>/g, '')
                     .replace(/<<<UNLOCK:.*?>>>/g, '')
                     .replace(/<<<QUIZ_START:.*?>>>/g, '')
                     .replace(/<<<CITATION:(.*?)>>>/g, '<span class="inline-flex items-center gap-1 px-2 py-0.5 rounded-md bg-accent/10 border border-accent/20 text-[10px] uppercase tracking-wider text-accent mx-1 select-none cursor-help" title="Source: Uploaded Document"><i class="fa-solid fa-file-pdf"></i> $1</span>')
                     .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
                     .replace(/\n/g, '<br/>');
      }

      function processSpecialTags(text, containerDiv) {
         if (!containerDiv) return;

         // Chart
         const chartMatch = text.match(/<<<CHART([\s\S]*?)CHART>>>/);
         if (chartMatch) {
             const jsonStr = chartMatch[1];
             try {
                 const chartData = JSON.parse(jsonStr);
                 const canvasId = 'chart-' + Date.now();
                 const canvasContainer = document.createElement('div');
                 canvasContainer.className = "mt-4 p-4 bg-[rgba(255,255,255,0.05)] rounded-xl border border-[rgba(255,255,255,0.1)]";
                 canvasContainer.innerHTML = `<canvas id="${canvasId}"></canvas>`;
                 
                 const textDiv = containerDiv.querySelector('.message-bubble') || containerDiv;
                 textDiv.appendChild(canvasContainer);
                 const msgs = document.getElementById('chat-messages');
                 if(msgs) msgs.scrollTop = msgs.scrollHeight;

                 import('chart.js/auto').then(({ default: Chart }) => {
                     const ctx = document.getElementById(canvasId);
                     if (ctx) {
                         new Chart(ctx, {
                             type: chartData.type,
                             data: chartData.data,
                             options: {
                                 ...chartData.options,
                                 color: 'rgba(255, 255, 255, 0.8)',
                                 borderColor: 'rgba(255, 255, 255, 0.2)',
                                 scale: {
                                    ticks: { color: 'rgba(255, 255, 255, 0.6)' },
                                    grid: { color: 'rgba(255, 255, 255, 0.05)' }
                                 },
                                 plugins: {
                                    legend: { labels: { color: 'rgba(255, 255, 255, 0.9)' } }
                                 }
                             }
                         });
                     }
                 });

             } catch (e) {
                 console.error("Chart Render Error", e);
             }
         }
         // Navigation
         const navMatch = text.match(/<<<NAVIGATE:\s*(.*?)\s*>>>/i);
         if (navMatch) {
             const rawPath = navMatch[1].trim();
             const path = rawPath.replace(/\.$/, '');
             const navDiv = document.createElement('div');
             navDiv.className = "flex items-center gap-2 text-sm text-accent mt-3 font-bold animate-pulse";
             navDiv.innerHTML = `<i class="fa-solid fa-arrow-right-long"></i> Navigating to ${path}...`;
             const bubble = containerDiv.querySelector('.message-bubble');
             if (bubble) bubble.appendChild(navDiv); 
             else containerDiv.appendChild(navDiv);
             const msgs = document.getElementById('chat-messages');
             if(msgs) msgs.scrollTop = msgs.scrollHeight;

             setTimeout(() => {
                 window.location.href = path;
             }, 500);
         }

         // Suggestions
         const suggestMatch = text.match(/<<<SUGGESTIONS:(.*?)>>>/);
         if (suggestMatch) {
              const jsonStr = suggestMatch[1];
              try {
                  const suggestions = JSON.parse(jsonStr);
                  const chipsContainer = document.createElement('div');
                  chipsContainer.className = "flex flex-wrap gap-2 mt-4 w-full";
                  
                  suggestions.forEach(s => {
                      const btn = document.createElement('button');
                      btn.className = "text-sm bg-accent/10 hover:bg-accent hover:text-bg text-accent border border-accent/20 rounded-xl px-4 py-2 transition-all duration-300 shadow-sm";
                      btn.innerText = s;
                      btn.addEventListener('click', () => {
                          const input = document.getElementById('chat-input'); // Fixed ID
                          const form = document.getElementById('chat-form');   // Fixed ID
                          if (input && form) {
                              input.value = s;
                              form.dispatchEvent(new Event('submit'));
                              chipsContainer.remove();
                          }
                      });
                      chipsContainer.appendChild(btn);
                  });
                  
                  containerDiv.appendChild(chipsContainer);
                  const msgs = document.getElementById('chat-messages');
                  if(msgs) msgs.scrollTop = msgs.scrollHeight;

              } catch (e) {
                  console.error("Suggestion Parse Error", e);
              }
         }

         // Gamification: Unlock
         const unlockMatch = text.match(/<<<UNLOCK:\s*["'](.*?)["']\s*>>>/);
         if (unlockMatch) {
             const achievementId = unlockMatch[1];
             console.log("üèÜ AI Unlocking Achievement:", achievementId);
             unlockAchievement(achievementId);
         }

         // Gamification: Quiz
         const quizMatch = text.match(/<<<QUIZ_START:\s*({.*?})\s*>>>/);
         if (quizMatch) {
             try {
                const quizdata = JSON.parse(quizMatch[1]);
                const quizDiv = document.createElement('div');
                quizDiv.className = "mt-4 p-4 bg-accent/10 border border-accent/30 rounded-xl animate-pulse";
                quizDiv.innerHTML = `
                    <div class="flex items-center gap-2 mb-2">
                        <i class="fa-solid fa-graduation-cap text-accent text-xl"></i>
                        <h4 class="font-bold text-accent">Quiz Mode Activated</h4>
                    </div>
                    <p class="text-sm text-dim-100">Topic: ${quizdata.topic}</p>
                `;
                containerDiv.appendChild(quizDiv);
                const msgs = document.getElementById('chat-messages');
                if(msgs) msgs.scrollTop = msgs.scrollHeight;
             } catch(e) { console.error("Quiz Parse Error", e); }
         }
      }

      const STORAGE_KEY = 'anton_ai_chat_history';

      function loadHistory() {
          const stored = localStorage.getItem(STORAGE_KEY);
          if (stored) {
              try {
                  const history = JSON.parse(stored);
                  history.forEach(msg => addMessage(msg.text, msg.role, true, msg.persona));
              } catch (e) { console.error(e); }
          }
      }

      function saveMessageToHistory(text, role, persona) {
          const stored = localStorage.getItem(STORAGE_KEY);
          let history = stored ? JSON.parse(stored) : [];
          history.push({ text, role, persona, timestamp: Date.now() });
          if (history.length > 50) history = history.slice(-50);
          localStorage.setItem(STORAGE_KEY, JSON.stringify(history));
      }

      document.getElementById('clear-widget-chat')?.addEventListener('click', () => {
         if(confirm("Clear chat history?")) {
             localStorage.removeItem(STORAGE_KEY);
             location.reload();
         }
      });

      function addMessage(text, role, skipSave = false, persona = 'default') {
        const msgs = document.getElementById('chat-messages');
        if (!msgs) return;
        
        if (!skipSave) saveMessageToHistory(text, role, persona);
        const div = document.createElement('div');
        div.className = `flex gap-4 ${role === 'user' ? 'flex-row-reverse' : ''}`;

        let contentElement;

        const titles = {
            'default': 'AI Analysis',
            'recruiter': 'üíº Recruiter Mode',
            'tech': 'üíª Tech Lead Mode',
            'eli5': 'üë∂ ELI5 Mode'
        };
        const displayTitle = titles[persona] || titles['default'];

        if (role === 'ai') {
          div.innerHTML = `
            <div class="w-10 h-10 rounded-full bg-accent/20 text-accent flex items-center justify-center flex-shrink-0 mt-1 border border-accent/20">
              <i class="fa-solid fa-robot text-lg"></i>
            </div>
            <div class="flex flex-col max-w-[85%] ai-content-wrapper">
                <div class="bg-white/5 border border-white/10 p-5 rounded-sm border-l-2 border-l-accent leading-relaxed text-dim-100 message-bubble shadow-lg">
                  <p class="font-mono text-xs text-accent mb-2 uppercase tracking-wide flex justify-between items-center">
                    <span>${displayTitle}</span>
                    ${persona !== 'default' ? '<i class="fa-solid fa-check-circle opacity-50"></i>' : ''}
                  </p>
                  <div class="prose prose-invert max-w-none text-sm md:text-base font-light">
                    ${formatText(text)}
                  </div>
                </div>
                
                <div class="flex gap-2 mt-2 ml-1">
                   ${text ? `
                   <button class="text-xs text-dim hover:text-accent transition-colors flex items-center gap-1 opacity-50 hover:opacity-100" onclick="navigator.clipboard.writeText(this.parentElement.previousElementSibling.innerText).then(() => alert('Copied!'))">
                      <i class="fa-regular fa-copy"></i>
                   </button>
                   ` : ''}
                </div>
            </div>
          `;
          contentElement = div.querySelector('.prose');
          if (text) contentElement.innerHTML = formatText(text);

          const actionsDiv = document.createElement('div');
          actionsDiv.className = "flex justify-end mt-2 gap-2";
          
          const safeText = encodeURIComponent(text);
          actionsDiv.innerHTML = `
             <button class="speak-btn pointer-events-auto text-dim-400 hover:text-accent transition-all duration-300 w-8 h-8 flex items-center justify-center rounded-full hover:bg-accent/10" aria-label="L√¶s h√∏jt" data-text="${safeText}" onclick="window.speakMessage(this.dataset.text, this); event.stopPropagation();">
                <i class="fa-solid fa-volume-high text-xs"></i>
             </button>
          `;
          div.querySelector('.ai-content-wrapper').appendChild(actionsDiv);
          
          if (text) {
               const wrapper = div.querySelector('.ai-content-wrapper');
               processSpecialTags(text, wrapper); 
          }

        } else {
          div.innerHTML = `
            <div class="bg-accent p-4 md:p-5 rounded-sm rounded-tr-none max-w-[85%] text-left shadow-lg font-medium text-sm md:text-base border border-accent">
              <p class="text-neutral-950 font-semibold">${text}</p>
            </div>
          `;
        }

        msgs.appendChild(div);
        msgs.scrollTop = msgs.scrollHeight;

        return contentElement;
      }

      let typingInterval;

      function showTyping() {
        const msgs = document.getElementById('chat-messages');
        if (!msgs) return;
        
        const div = document.createElement('div');
        div.id = 'fp-typing';
        div.className = 'flex gap-4';
        
        div.innerHTML = `
           <div class="w-10 h-10 rounded-full bg-accent text-bg flex items-center justify-center flex-shrink-0 mt-1 animate-pulse">
              <i class="fa-solid fa-microchip text-lg"></i>
            </div>
            <div class="bg-[rgba(255,255,255,0.05)] border border-accent/20 p-4 rounded-2xl rounded-tl-none flex items-center">
              <span id="typing-text" class="text-xs font-mono text-accent tracking-wider">‚ö° Initializing Quantum Core...</span>
            </div>
        `;
        msgs.appendChild(div);
        msgs.scrollTop = msgs.scrollHeight;

        const states = [
            "‚ö° Initializing Quantum Core...",
            "üå™Ô∏è Reading Context & Metadata...",
            "üìö Searching Knowledge Base...",
            "üß† Analyzing Economic Models...",
            "‚ú® Generating Response..."
        ];
        
        let stateIdx = 0;
        const textSpan = div.querySelector('#typing-text');
        
        if (textSpan) {
            typingInterval = setInterval(() => {
                stateIdx = (stateIdx + 1) % states.length;
                textSpan.textContent = states[stateIdx];
            }, 800);
        }
      }

      function removeTyping() {
        if (typingInterval) clearInterval(typingInterval);
        const el = document.getElementById('fp-typing');
        if (el) el.remove();
      }

      loadHistory();

  } catch (err) {
      console.error("Chat Widget Script Error:", err);
  }
</script>
<script is:inline src="/assets/js/voice-widget.js"></script>
