import fs from 'fs/promises';
import path from 'path';
import { createRequire } from 'module';

const require = createRequire(import.meta.url);
let pdf;
try {
    const pdfModule = require('pdf-parse');
    // On Vercel, it seems pdfModule might be the object containing the function or just the function
    // Debug output showed keys including 'PDFParse'.
    console.log('DEBUG: pdf-parse loaded. Keys:', Object.keys(pdfModule));

    // Try to find the function: default -> PDFParse property -> module itself
    // Priority: default -> PDFParse (if function) -> module itself
    if (typeof pdfModule === 'function') {
        pdf = pdfModule;
    } else if (pdfModule.default && typeof pdfModule.default === 'function') {
        pdf = pdfModule.default;
    } else if (pdfModule.PDFParse && typeof pdfModule.PDFParse === 'function') {
        pdf = pdfModule.PDFParse;
    } else {
        console.warn("WARNING: Could not find pdf function in pdf-parse module. Keys:", Object.keys(pdfModule));
        // Fallback: try default or module, whatever works (or crash later)
        pdf = pdfModule.default || pdfModule;
    }

    // If it's still not a function, we are in trouble, but let's try to assume it works if called or use the one from keys
    if (typeof pdf !== 'function' && typeof pdfModule.PDFParse === 'function') {
        pdf = pdfModule.PDFParse;
    }
} catch (e) {
    console.error('DEBUG: Failed to require pdf-parse:', e);
}

const documentsDir = './src/data/documents';
const outputFile = './src/lib/generated-rag.ts';

async function processDocs() {
    console.log("ðŸ“„ Processing RAG Documents...");

    try {
        await fs.access(documentsDir);
    } catch {
        console.warn("âš ï¸ No documents directory found. Skipping.");
        await fs.writeFile(outputFile, 'export const ragContent = "";');
        return;
    }

    const files = await fs.readdir(documentsDir);
    let allText = "";

    for (const file of files) {
        const filePath = path.join(documentsDir, file);

        try {
            if (file.endsWith('.pdf')) {
                console.log(`   - Reading PDF: ${file}`);
                const buffer = await fs.readFile(filePath);
                try {
                    const data = await pdf(buffer);
                    // Clean up text slightly to save space
                    const cleanText = data.text.replace(/\n\s*\n/g, '\n').trim();
                    allText += `\n--- START DOCUMENT: ${file} ---\n${cleanText}\n--- END DOCUMENT ---\n`;
                } catch (pdfError) {
                    console.error(`   âŒ Failed to parse PDF ${file}:`, pdfError.message);
                }
            }
            else if (file.endsWith('.txt') || file.endsWith('.md')) {
                console.log(`   - Reading Text: ${file}`);
                const text = await fs.readFile(filePath, 'utf-8');
                allText += `\n--- START DOCUMENT: ${file} ---\n${text.trim()}\n--- END DOCUMENT ---\n`;
            }
        } catch (err) {
            console.error(`âŒ Error processing ${file}:`, err.message);
        }
    }

    // Escape backticks and standard JS escaping for the string content
    const escapedText = allText.replace(/\\/g, '\\\\').replace(/`/g, '\\`').replace(/\${/g, '\\${');

    // LIMIT SIZE TO PREVENT BUILD HANGS (Temporary Fix)
    const limitedText = escapedText.length > 50000 ? escapedText.substring(0, 50000) + "\n[TRUNCATED]" : escapedText;

    const fileContent = `// Auto-generated by scripts/process-docs.mjs
// Do not edit manually.
export const ragContent = \`${limitedText}\`;
`;

    await fs.writeFile(outputFile, fileContent);
    console.log(`âœ… RAG Content generated at ${outputFile} (Truncated to ${limitedText.length} chars)`);
}

processDocs();
