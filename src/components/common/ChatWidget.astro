---
import { getLangFromUrl } from '@i18n/utils';

const lang = getLangFromUrl(Astro.url);

const t = {
  da: {
    title: "Anton's AI",
    online: "Online",
    intro: "Hej! Jeg er Antons AI-assistent. Sp√∏rg mig om hans erfaring, eller bed mig om at <strong>vise en graf</strong> over hans kompetencer!",
    placeholder: "Pr√∏v f.eks: 'Vis mig en graf over dine skills'...",
    disclaimer: "Drevet af AI ¬∑ Kan lave fejl",
    error: "Beklager, jeg st√∏dte p√• en fejl.",
    configError: "Konfigurationsfejl: Mangler API-n√∏gle.",
    serverError: "Beklager, jeg kan ikke f√• forbindelse til serveren.",
    prompts: ["üìä Vis mig en graf over Antons skills", "üíº Opsummer Antons erfaring", "üöÄ Hvorfor skal jeg ans√¶tte Anton?"]
  },
  en: {
    title: "Anton's AI",
    online: "Online",
    intro: "Hi! I'm Anton's AI assistant. Ask me about his experience, or ask me to <strong>graph his skills</strong>!",
    placeholder: "Try: 'Show me a graph of your skills'...",
    disclaimer: "Powered by AI ¬∑ May produce inaccuracies",
    error: "Sorry, I encountered an error.",
    configError: "Configuration Error: Missing API Key.",
    serverError: "Sorry, I'm having trouble reaching the server.",
    prompts: ["üìä Graph Anton's skills", "üíº Summarize Anton's experience", "üöÄ Why should I hire Anton?"]
  }
}[lang];
---

<script is:inline src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
<script is:inline>
    // Initialize PDF.js worker if not already done
    if (window.pdfjsLib && !window.pdfjsLib.GlobalWorkerOptions.workerSrc) {
        window.pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
    }
</script>

<div id="chat-widget" class="fixed bottom-4 right-4 md:bottom-6 md:right-6 z-50 flex flex-col items-end pointer-events-none" data-lang={lang}>
  
  <!-- Chat Window -->
  <div id="chat-window" class="w-[calc(100vw-2rem)] md:w-[350px] h-[500px] max-h-[75vh] mb-4 bg-glass border border-glass-border rounded-xl shadow-2xl flex flex-col transform translate-y-10 opacity-0 pointer-events-auto transition-all duration-300 origin-bottom-right hidden">
    
    <!-- Header -->
    <div id="chat-header" class="p-4 border-b border-glass-border flex justify-between items-center bg-accent/5 rounded-t-xl cursor-move select-none">
      <div class="flex items-center gap-3">
        <div class="w-8 h-8 rounded-full bg-accent text-bg flex items-center justify-center">
          <i class="fa-solid fa-robot"></i>
        </div>
        <div>
          <h3 class="font-bold text-sm">{t.title}</h3>
          <p class="text-[10px] text-accent flex items-center gap-1">
            <span class="w-1.5 h-1.5 rounded-full bg-green-500 animate-pulse"></span> {t.online}
          </p>
        </div>
      </div>
      <div class="flex gap-2 items-center">
        <!-- Persona Selector -->
        <div class="relative group mr-1">
            <select id="widget-persona-select" class="appearance-none bg-neutral-900 border border-accent/20 text-white text-[10px] rounded-md py-1 pl-2 pr-6 cursor-pointer hover:bg-neutral-800 transition-colors focus:outline-none">
                <option value="default" class="bg-neutral-900 text-white">Standard</option>
                <option value="recruiter" class="bg-neutral-900 text-white">üíº Recruiter</option>
                <option value="tech" class="bg-neutral-900 text-white">üíª Tech Lead</option>
                <option value="eli5" class="bg-neutral-900 text-white">üë∂ ELI5</option>
            </select>
            <i class="fa-solid fa-chevron-down absolute right-2 top-1/2 -translate-y-1/2 text-[8px] text-accent pointer-events-none"></i>
        </div>

        <a href="/chat" class="text-dim hover:text-accent transition-colors p-1" title={lang==='da' ? "√Öbn stor chat" : "Open full chat"}>
          <i class="fa-solid fa-expand"></i>
        </a>
        <a href="/ai-project" class="text-dim hover:text-accent transition-colors p-1" title={lang==='da' ? "Om denne AI" : "About this AI"}>
          <i class="fa-solid fa-circle-info"></i>
        </a>
        <button id="clear-widget-chat" class="text-dim hover:text-red-400 transition-colors p-1" title={lang==='da' ? "Slet historik" : "Clear history"}>
           <i class="fa-solid fa-trash"></i>
        </button>
        <button id="close-chat" class="text-dim hover:text-white transition-colors p-1">
          <i class="fa-solid fa-xmark"></i>
        </button>
      </div>
    </div>

    <!-- Messages -->
    <div id="chat-messages" class="flex-1 p-4 overflow-y-auto space-y-4 scrollbar-hide text-sm">
      <div class="flex gap-2">
        <div class="w-6 h-6 rounded-full bg-accent/20 flex-shrink-0 flex items-center justify-center text-[10px] text-accent mt-1">
          <i class="fa-solid fa-robot"></i>
        </div>
        <div class="bg-glass-border/50 p-3 rounded-lg rounded-tl-none max-w-[85%] border border-accent">
          <p set:html={t.intro} />
        </div>
      </div>
      
      <!-- Quick Prompts -->
      <div class="grid grid-cols-1 gap-2 pl-12">
         {t.prompts.map(p => (
           <button class="text-left text-xs bg-white/5 border border-white/10 hover:bg-white/10 hover:border-accent/50 transition-colors rounded-lg p-2 text-dim hover:text-white quick-prompt-btn">
             {p}
           </button>
         ))}
      </div>
      
      <!-- Messages will appear here -->
    </div>

    <!-- Input -->
    <div class="p-3 border-t border-glass-border bg-glass/50 rounded-b-xl">
      <form id="chat-form" class="flex gap-2">
        <input 
          type="text" 
          id="chat-input"
          placeholder={t.placeholder}
          class="flex-1 bg-neutral-900 border border-glass-border rounded-lg px-3 py-2 text-sm text-white focus:outline-none focus:border-accent/50 transition-colors placeholder:text-white/40"
          autocomplete="off"
        />
        <input type="file" id="chat-file" hidden accept=".pdf,.txt,.md,.csv" />
        <button type="button" id="file-btn" class="bg-glass/20 text-dim hover:text-white hover:bg-glass/40 w-9 h-9 rounded-lg flex items-center justify-center transition-all group" title="Upload Document">
            <i class="fa-solid fa-paperclip text-xs group-hover:scale-110 transition-transform"></i>
        </button>
        <button type="button" id="voice-btn" class="bg-glass/20 text-dim hover:text-white hover:bg-glass/40 w-9 h-9 rounded-lg flex items-center justify-center transition-all group relative" title="Speak to Anton (Voice Mode)">
           <i class="fa-solid fa-microphone text-xs group-hover:scale-110 transition-transform"></i>
           <span class="absolute inset-0 rounded-lg border border-red-500 opacity-0 transition-opacity" id="voice-indicator"></span>
        </button>
        <button type="submit" class="bg-accent text-bg w-9 h-9 rounded-lg flex items-center justify-center hover:bg-white transition-colors">
          <i class="fa-solid fa-paper-plane text-xs"></i>
        </button>
      </form>
      <div id="file-display" class="hidden mt-2 px-2 py-1 bg-accent/10 border border-accent/20 rounded flex items-center justify-between text-[10px] text-accent">
          <span class="truncate flex-1 font-mono"><i class="fa-solid fa-file-pdf mr-1"></i><span id="filename"></span></span>
          <button type="button" id="remove-file" class="ml-2 hover:text-white"><i class="fa-solid fa-times"></i></button>
      </div>
      <div class="text-[10px] text-center text-dim/30 mt-2">
        {t.disclaimer}
      </div>
    </div>
  </div>

  <!-- Toggle Button -->
  <button id="chat-toggle" aria-label="Open AI Assistant" class="pointer-events-auto w-14 h-14 bg-accent text-bg rounded-full shadow-lg shadow-accent/20 flex items-center justify-center hover:bg-white hover:scale-110 transition-all duration-300 group">
    <i class="fa-solid fa-message text-xl group-hover:scale-110 transition-transform"></i>
  </button>

</div>

<script is:inline>
// @ts-nocheck
// This file is now ignored by TS largely, but we will fix key items if the ignore fails.
  try {
      // Elements
      const voiceIndicator = document.getElementById('voice-indicator');
      const widget = document.getElementById('chat-widget');
      const chatWindow = document.getElementById('chat-window');
      const toggle = document.getElementById('chat-toggle');
      const close = document.getElementById('close-chat');
      const form = document.getElementById('chat-form');
      const input = document.getElementById('chat-input');
      const voiceBtn = document.getElementById('voice-btn');
      const fileInput = document.getElementById('chat-file');
      const fileBtn = document.getElementById('file-btn');
      const fileDisplay = document.getElementById('file-display');
      const fileNameSpan = document.getElementById('file-name');
      const removeFileBtn = document.getElementById('remove-file');
      const contentElement = document.getElementById('chat-content');
      const personaSelect = document.getElementById('persona-select');
      const header = document.getElementById('chat-header');
      const messages = document.getElementById('chat-messages');

      // Concierge Logic
      const currentLang = widget?.getAttribute('data-lang') || 'da';
      const currentPath = window.location.pathname; // Global window
      
      const conciergeMessages = {
          '/cv': {
              da: "Har du sp√∏rgsm√•l til min erfaring eller specifikke roller?",
              en: "Do you have questions about my experience or specific roles?"
          },
          '/portfolio': {
              da: "Jeg kan forklare teknologistakken bag disse projekter. Sp√∏rg l√∏s!",
              en: "I can explain the tech stack behind these projects. Ask away!"
          },
          '/blog': {
              da: "L√¶ser du mine tanker? Jeg kan opsummere ethvert blogindl√¶g for dig.",
              en: "Reading my thoughts? I can summarize any post for you."
          },
          '/ai-project': {
              da: "Nysgerrig p√• hvordan jeg arbejder? Sp√∏rg mig om min RAG-arkitektur!",
              en: "Curious about how I work? Ask me about my RAG architecture!"
          }
      };

      try {
          const matchedPath = Object.keys(conciergeMessages).find(path => currentPath.startsWith(path));
          
          if (matchedPath) {
             const msg = conciergeMessages[matchedPath][currentLang];
             const introText = document.querySelector('#chat-messages p');
             if (introText) {
                 introText.textContent = msg;
                 introText.parentElement.classList.add('border-accent', 'border');
             }
          }
      } catch(err) {
          console.error("Concierge Error:", err);
      }

      // UI Logic
      let isOpen = false;

      function toggleChat() {
        if (!chatWindow || !toggle) return;
        
        isOpen = !isOpen;
        if (isOpen) {
          chatWindow.classList.remove('hidden');
          setTimeout(() => {
            chatWindow.classList.remove('translate-y-10', 'opacity-0');
            toggle.classList.add('scale-0', 'opacity-0');
            toggle.style.display = 'none'; 
          }, 10);
          input?.focus();
        } else {
          chatWindow.classList.add('translate-y-10', 'opacity-0');
          toggle.style.display = 'flex';
          setTimeout(() => {
             toggle.classList.remove('scale-0', 'opacity-0');
          }, 10);
          setTimeout(() => {
            chatWindow.classList.add('hidden');
          }, 300);
        }
      }

      if (toggle) toggle.addEventListener('click', toggleChat);
      if (close) close.addEventListener('click', toggleChat);

      // File Upload Logic
      let currentFileContent = null;

      fileBtn?.addEventListener('click', () => fileInput?.click());

      fileInput?.addEventListener('change', async (e) => {
          const file = (e.target as HTMLInputElement).files?.[0];
          if (!file) return;

          if(fileDisplay && fileNameSpan) {
              fileDisplay.classList.remove('hidden');
              fileNameSpan.textContent = "Processing..." + file.name;
          }

          try {
              let text = "";
              if (file.type === 'application/pdf') {
                  if(!window.pdfjsLib) throw new Error("PDF.js not loaded");
                  const arrayBuffer = await file.arrayBuffer();
                  const pdf = await window.pdfjsLib.getDocument({ data: arrayBuffer }).promise;
                  for (let i = 1; i <= pdf.numPages; i++) {
                      const page = await pdf.getPage(i);
                      const content = await page.getTextContent();
                      text += content.items.map(item => item.str).join(' ') + "\n";
                  }
              } else {
                  text = await file.text();
              }

              currentFileContent = `\n\n<<<FILE_CONTENT Start: ${file.name}>>>\n${text}\n<<<FILE_CONTENT End>>>\n`;
              if(fileNameSpan) fileNameSpan.textContent = file.name + " (Ready)";
              
          } catch (err) {
              console.error("File read error:", err);
              if(fileNameSpan) fileNameSpan.textContent = "Error reading file";
              currentFileContent = null;
          }
      });

      removeFileBtn?.addEventListener('click', () => {
          currentFileContent = null;
          if (fileInput) fileInput.value = '';
          fileDisplay?.classList.add('hidden');
      });
      
      // Persona Logic
      const personaSelectElement = document.getElementById('widget-persona-select');
      if (personaSelectElement) {
          const savedPersona = localStorage.getItem('anton_ai_persona');
          if (savedPersona) personaSelectElement.value = savedPersona;
          
          // Event Listeners for Persona
          personaSelectElement?.addEventListener('change', (e) => {
            const val = e.target.value;
            const p = t.personas[val] || t.personas['default'];
            
            // Update UI
            if(header) {
                header.innerHTML = `<i class="${p.icon} mr-2"></i> ${p.name}`;
                header.className = `p-4 border-b border-glass-border flex justify-between items-center rounded-t-xl bg-gradient-to-r ${p.color}`;
            }
            
            // Add system message about switch
            addMessage(`System: Switched to ${p.name} mode. ${p.description}`, 'system', true, val);
          });
      }

      // Draggable Logic
      let isDragging = false;
      let currentX;
      let currentY;
      let initialX;
      let initialY;
      let xOffset = 0;
      let yOffset = 0;

      if (header && chatWindow) {
          header.addEventListener('mousedown', dragStart);
          document.addEventListener('mousemove', drag);
          document.addEventListener('mouseup', dragEnd);
          
          // Touch support
          header.addEventListener('touchstart', dragStart, {passive: false});
          document.addEventListener('touchmove', drag, {passive: false});
          document.addEventListener('touchend', dragEnd);
      }

      function dragStart(e) {
         if (e.target.closest('button') || e.target.closest('a')) return; // Allow clicking buttons in header
         
         if (e.type === "touchstart") {
             initialX = e.touches[0].clientX - xOffset;
             initialY = e.touches[0].clientY - yOffset;
         } else {
             initialX = e.clientX - xOffset;
             initialY = e.clientY - yOffset;
         }

         if (e.target === header || header.contains(e.target)) {
             isDragging = true;
             // Fix the window in place relative to viewport once dragging starts
             const rect = chatWindow.getBoundingClientRect();
             
             // Important: We need to break out of the flex container constraints
             // Switch to fixed positioning if not already
             if (chatWindow.style.position !== 'fixed') {
                 chatWindow.style.position = 'fixed';
                 chatWindow.style.left = rect.left + 'px';
                 chatWindow.style.top = rect.top + 'px';
                 chatWindow.style.marginBottom = '0';
                 chatWindow.style.transform = 'none'; // distinct from open animation
                 
                 // Recalculate offsets after switching to fixed
                 // But simply starting translate from 0,0 is easier if we track delta
                  initialX = e.clientX || e.touches[0].clientX;
                  initialY = e.clientY || e.touches[0].clientY;
                 
                 // Store current top/left
                 xOffset = rect.left;
                 yOffset = rect.top;
             }
         }
      }

      function dragEnd() {
         initialX = currentX;
         initialY = currentY;
         isDragging = false;
      }

      function drag(e) {
         if (isDragging) {
             e.preventDefault();
             
             let clientX, clientY;
             if (e.type === "touchmove") {
                 clientX = e.touches[0].clientX;
                 clientY = e.touches[0].clientY;
             } else {
                 clientX = e.clientX;
                 clientY = e.clientY;
             }

             // Calculate new position
             const dx = clientX - initialX;
             const dy = clientY - initialY;
             
             currentX = xOffset + dx;
             currentY = yOffset + dy;

             // Boundary checks (keep on screen)
             const rect = chatWindow.getBoundingClientRect();
             const viewportWidth = window.innerWidth;
             const viewportHeight = window.innerHeight;
             
             // Clamp X
             if (currentX < 0) currentX = 0;
             if (currentX + rect.width > viewportWidth) currentX = viewportWidth - rect.width;
             
             // Clamp Y
             if (currentY < 0) currentY = 0;
             if (currentY + rect.height > viewportHeight) currentY = viewportHeight - rect.height;
             
             // Update position (since we are fixed mode)
             chatWindow.style.left = currentX + 'px';
             chatWindow.style.top = currentY + 'px';
         }
      }

      // Voice Logic
      // Check if browser supports speech recognition
      let recognition;
      if ('webkitSpeechRecognition' in window || 'SpeechRecognition' in window) {
          const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
          recognition = new SpeechRecognition();
          recognition.continuous = false;
          recognition.lang = currentLang === 'da' ? 'da-DK' : 'en-US';
          recognition.interimResults = false;

          recognition.onstart = () => {
              if(voiceIndicator) {
                  voiceIndicator.classList.remove('opacity-0');
                  voiceIndicator.classList.add('animate-pulse', 'border-red-500');
              }
              voiceBtn?.classList.add('text-red-400');
          };

          recognition.onend = () => {
              if(voiceIndicator) {
                  voiceIndicator.classList.add('opacity-0');
                  voiceIndicator.classList.remove('animate-pulse', 'border-red-500');
              }
              voiceBtn?.classList.remove('text-red-400');
          };

          recognition.onerror = (event) => {
              console.error("üé§ FP Voice error:", event.error);
              if(voiceIndicator) voiceIndicator.classList.add('opacity-0');
              voiceBtn?.classList.remove('text-red-400');
              if (event.error === 'not-allowed') {
                  alert("Microphone access denied.");
              }
          };

          recognition.onresult = (event) => {
              const transcript = event.results[0][0].transcript;
              if (input) {
                  input.value = transcript;
                  input.focus();
              }
          };

          voiceBtn?.addEventListener('click', () => {
              try {
                  recognition.start();
              } catch (e) {
                  console.log("Recognition already started or error:", e);
                  recognition.stop();
              }
          });
      } else {
          if(voiceBtn) voiceBtn.style.display = 'none';
      }

      // Quick Prompts Logic
      document.querySelectorAll('.quick-prompt-btn').forEach(btn => {
        btn.addEventListener('click', (e) => {
            const text = e.currentTarget.textContent?.trim();
            if(text && input && form) {
                input.value = text;
                form.dispatchEvent(new Event('submit'));
                e.currentTarget.parentElement?.remove();
            }
        });
      });

      // Submit Logic
      if (form) {
          form.addEventListener('submit', async (e) => {
            e.preventDefault();
            const query = input?.value.trim() || "";
            if (!query && !currentFileContent) return;

            const persona = localStorage.getItem('anton_ai_persona') || 'default';

            addMessage(query || (currentFileContent ? `[Attached: ${fileInput?.files?.[0]?.name}]` : "Empty message"), 'user', false, persona);
            
            const fullPayload = query + (currentFileContent || "");
            
            if (input) input.value = '';
            
            if(currentFileContent) {
                removeFileBtn?.click();
            }

            showTyping();
            
            try {
              const res = await fetch('/api/chat', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ message: fullPayload, lang: currentLang, persona })
              });
              
              removeTyping();

              if (!res.ok) {
                 const text = await res.text();
                 let errorMsg = `Server Error (${res.status})`;
                 if (text) {
                     try {
                         const data = JSON.parse(text);
                         errorMsg = data.message || errorMsg;
                     } catch (e) {
                         // Valid text but not JSON (e.g. HTML error page)
                         errorMsg += `: ${text.substring(0, 100)}...`;
                     }
                 } else {
                     errorMsg += ": Empty Response";
                 }
                 
                 addMessage("‚ö†Ô∏è " + errorMsg, 'ai', false, persona);
                 return;
              }

              const messageContent = addMessage("", 'ai', true, persona);
              const reader = res.body?.getReader();
              const decoder = new TextDecoder();
              let accumulatedText = "";

              if (reader) {
                  while (true) {
                      const { done, value } = await reader.read();
                      if (done) break;
                      
                      const chunk = decoder.decode(value, { stream: true });
                      accumulatedText += chunk;
                      
                      if (messageContent) {
                          messageContent.innerHTML = formatText(accumulatedText);
                      }
                      const msgs = document.getElementById('chat-messages');
                      if(msgs) msgs.scrollTop = msgs.scrollHeight;
                  }
              }

              // Save to history
              saveMessageToHistory(accumulatedText, 'ai', persona);

              if (messageContent) {
                   const wrapper = messageContent.closest('.ai-content-wrapper');
                   processSpecialTags(accumulatedText, wrapper); 
              }

            } catch (err) {
              removeTyping();
              console.error(err);
              addMessage(`‚ö†Ô∏è Connection error: ${err.message || 'Unknown'}`, 'ai');
            }
          });
      }

      // Helpers
      function formatText(text) {
          // Simple link formatting
          return text.replace(/<<<CHART[\s\S]*?CHART>>>/g, '')
                     .replace(/<<<NAVIGATE:.*?>>>/gi, '')
                     .replace(/<<<SUGGESTIONS:.*?>>>/g, '')
                     .replace(/<<<CITATION:(.*?)>>>/g, '<span class="inline-flex items-center gap-1 px-2 py-0.5 rounded-md bg-accent/10 border border-accent/20 text-[10px] uppercase tracking-wider text-accent mx-1 select-none cursor-help" title="Source: Uploaded Document"><i class="fa-solid fa-file-pdf"></i> $1</span>')
                     .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
                     .replace(/\n/g, '<br/>');
      }

      function processSpecialTags(text, containerDiv) {
         if (!containerDiv) return;

         // Chart
         const chartMatch = text.match(/<<<CHART([\s\S]*?)CHART>>>/);
         if (chartMatch) {
             const jsonStr = chartMatch[1];
             try {
                 const chartData = JSON.parse(jsonStr);
                 const canvasId = 'chart-' + Date.now();
                 const canvasContainer = document.createElement('div');
                 canvasContainer.className = "mt-4 p-4 bg-[rgba(255,255,255,0.05)] rounded-xl border border-[rgba(255,255,255,0.1)]";
                 canvasContainer.innerHTML = `<canvas id="${canvasId}"></canvas>`;
                 
                 const textDiv = containerDiv.querySelector('.message-bubble') || containerDiv;
                 textDiv.appendChild(canvasContainer);
                 const msgs = document.getElementById('chat-messages');
                 if(msgs) msgs.scrollTop = msgs.scrollHeight;

                 import('chart.js/auto').then(({ default: Chart }) => {
                     const ctx = document.getElementById(canvasId);
                     if (ctx) {
                         new Chart(ctx, {
                             type: chartData.type,
                             data: chartData.data,
                             options: {
                                 ...chartData.options,
                                 color: 'rgba(255, 255, 255, 0.8)',
                                 borderColor: 'rgba(255, 255, 255, 0.2)',
                                 scale: {
                                    ticks: { color: 'rgba(255, 255, 255, 0.6)' },
                                    grid: { color: 'rgba(255, 255, 255, 0.05)' }
                                 },
                                 plugins: {
                                    legend: { labels: { color: 'rgba(255, 255, 255, 0.9)' } }
                                 }
                             }
                         });
                     }
                 });

             } catch (e) {
                 console.error("Chart Render Error", e);
             }
         }
         // Navigation
         const navMatch = text.match(/<<<NAVIGATE:\s*(.*?)\s*>>>/i);
         if (navMatch) {
             const rawPath = navMatch[1].trim();
             const path = rawPath.replace(/\.$/, '');
             const navDiv = document.createElement('div');
             navDiv.className = "flex items-center gap-2 text-sm text-accent mt-3 font-bold animate-pulse";
             navDiv.innerHTML = `<i class="fa-solid fa-arrow-right-long"></i> Navigating to ${path}...`;
             const bubble = containerDiv.querySelector('.message-bubble');
             if (bubble) bubble.appendChild(navDiv); 
             else containerDiv.appendChild(navDiv);
             const msgs = document.getElementById('chat-messages');
             if(msgs) msgs.scrollTop = msgs.scrollHeight;

             setTimeout(() => {
                 window.location.href = path;
             }, 500);
         }

         // Suggestions
         const suggestMatch = text.match(/<<<SUGGESTIONS:(.*?)>>>/);
         if (suggestMatch) {
              const jsonStr = suggestMatch[1];
              try {
                  const suggestions = JSON.parse(jsonStr);
                  const chipsContainer = document.createElement('div');
                  chipsContainer.className = "flex flex-wrap gap-2 mt-4 w-full";
                  
                  suggestions.forEach(s => {
                      const btn = document.createElement('button');
                      btn.className = "text-sm bg-accent/10 hover:bg-accent hover:text-bg text-accent border border-accent/20 rounded-xl px-4 py-2 transition-all duration-300 shadow-sm";
                      btn.innerText = s;
                      btn.addEventListener('click', () => {
                          if (input && form) {
                              input.value = s;
                              form.dispatchEvent(new Event('submit'));
                              chipsContainer.remove();
                          }
                      });
                      chipsContainer.appendChild(btn);
                  });
                  
                  containerDiv.appendChild(chipsContainer);
                  const msgs = document.getElementById('chat-messages');
                  if(msgs) msgs.scrollTop = msgs.scrollHeight;

              } catch (e) {
                  console.error("Suggestion Parse Error", e);
              }
         }
      }

      const STORAGE_KEY = 'anton_ai_chat_history';

      function loadHistory() {
          const stored = localStorage.getItem(STORAGE_KEY);
          if (stored) {
              try {
                  const history = JSON.parse(stored);
                  history.forEach(msg => addMessage(msg.text, msg.role, true, msg.persona));
              } catch (e) { console.error(e); }
          }
      }

      function saveMessageToHistory(text, role, persona) {
          const stored = localStorage.getItem(STORAGE_KEY);
          let history = stored ? JSON.parse(stored) : [];
          history.push({ text, role, persona, timestamp: Date.now() });
          if (history.length > 50) history = history.slice(-50);
          localStorage.setItem(STORAGE_KEY, JSON.stringify(history));
      }

      document.getElementById('clear-widget-chat')?.addEventListener('click', () => {
         if(confirm("Clear chat history?")) {
             localStorage.removeItem(STORAGE_KEY);
             location.reload();
         }
      });

      function addMessage(text, role, skipSave = false, persona = 'default') {
        const msgs = document.getElementById('chat-messages');
        if (!msgs) return;
        
        if (!skipSave) saveMessageToHistory(text, role, persona);
        const div = document.createElement('div');
        div.className = `flex gap-4 ${role === 'user' ? 'flex-row-reverse' : ''}`;

        let contentElement;

        // Map personas to titles
        const titles = {
            'default': 'AI Analysis',
            'recruiter': 'üíº Recruiter Mode',
            'tech': 'üíª Tech Lead Mode',
            'eli5': 'üë∂ ELI5 Mode'
        };
        const displayTitle = titles[persona] || titles['default'];

        if (role === 'ai') {
          div.innerHTML = `
            <div class="w-10 h-10 rounded-full bg-accent/20 text-accent flex items-center justify-center flex-shrink-0 mt-1 border border-accent/20">
              <i class="fa-solid fa-robot text-lg"></i>
            </div>
            <div class="flex flex-col max-w-[85%] ai-content-wrapper">
                <div class="bg-white/5 border border-white/10 p-5 rounded-sm border-l-2 border-l-accent leading-relaxed text-dim-100 message-bubble shadow-lg">
                  <p class="font-mono text-xs text-accent mb-2 uppercase tracking-wide flex justify-between items-center">
                    <span>${displayTitle}</span>
                    ${persona !== 'default' ? '<i class="fa-solid fa-check-circle opacity-50"></i>' : ''}
                  </p>
                  <div class="prose prose-invert max-w-none text-sm md:text-base font-light">
                    ${formatText(text)}
                  </div>
                </div>
                
                <div class="flex gap-2 mt-2 ml-1">
                   ${text ? `
                   <button class="text-xs text-dim hover:text-accent transition-colors flex items-center gap-1 opacity-50 hover:opacity-100" onclick="navigator.clipboard.writeText(this.parentElement.previousElementSibling.innerText).then(() => alert('Copied!'))">
                      <i class="fa-regular fa-copy"></i>
                   </button>
                   ` : ''}
                </div>
            </div>
          `;
          contentElement = div.querySelector('.prose');
          if (text) contentElement.innerHTML = formatText(text);

          // Add Speak Button (Handled by public/assets/js/voice-widget.js)
          const actionsDiv = document.createElement('div');
          actionsDiv.className = "flex justify-end mt-2 gap-2";
          
          const safeText = encodeURIComponent(text);
          actionsDiv.innerHTML = `
             <button class="speak-btn pointer-events-auto text-dim-400 hover:text-accent transition-all duration-300 w-8 h-8 flex items-center justify-center rounded-full hover:bg-accent/10" aria-label="L√¶s h√∏jt" data-text="${safeText}" onclick="window.speakMessage(this.dataset.text, this); event.stopPropagation();">
                <i class="fa-solid fa-volume-high text-xs"></i>
             </button>
          `;
          div.querySelector('.ai-content-wrapper').appendChild(actionsDiv);
          
          // Process Tags (Charts, Suggestions) for restored history
          if (text) {
               const wrapper = div.querySelector('.ai-content-wrapper');
               processSpecialTags(text, wrapper); 
          }

        } else {
          div.innerHTML = `
            <div class="bg-accent p-4 md:p-5 rounded-sm rounded-tr-none max-w-[85%] text-left shadow-lg font-medium text-sm md:text-base border border-accent">
              <p class="text-neutral-950 font-semibold">${text}</p>
            </div>
          `;
        }

        msgs.appendChild(div);
        msgs.scrollTop = msgs.scrollHeight;

        return contentElement;
      }

      let typingInterval;

      function showTyping() {
        const msgs = document.getElementById('chat-messages');
        if (!msgs) return;
        
        const div = document.createElement('div');
        div.id = 'fp-typing';
        div.className = 'flex gap-4';
        
        // Initial State
        div.innerHTML = `
           <div class="w-10 h-10 rounded-full bg-accent text-bg flex items-center justify-center flex-shrink-0 mt-1 animate-pulse">
              <i class="fa-solid fa-microchip text-lg"></i>
            </div>
            <div class="bg-[rgba(255,255,255,0.05)] border border-accent/20 p-4 rounded-2xl rounded-tl-none flex items-center">
              <span id="typing-text" class="text-xs font-mono text-accent tracking-wider">‚ö° Initializing Quantum Core...</span>
            </div>
        `;
        msgs.appendChild(div);
        msgs.scrollTop = msgs.scrollHeight;

        const states = [
            "‚ö° Initializing Quantum Core...",
            "üå™Ô∏è Reading Context & Metadata...",
            "üìö Searching Knowledge Base...",
            "üß† Analyzing Economic Models...",
            "‚ú® Generating Response..."
        ];
        
        let stateIdx = 0;
        const textSpan = div.querySelector('#typing-text');
        
        if (textSpan) {
            typingInterval = setInterval(() => {
                stateIdx = (stateIdx + 1) % states.length;
                textSpan.textContent = states[stateIdx];
            }, 800);
        }
      }

      function removeTyping() {
        if (typingInterval) clearInterval(typingInterval);
        const el = document.getElementById('fp-typing');
        if (el) el.remove();
      }

      // Old TTS logic removed - now in /public/assets/js/voice-widget.js

      // Init History
      loadHistory();

  } catch (err) {
      console.error("Chat Widget Script Error:", err);
  }
</script>
<script is:inline src="/assets/js/voice-widget.js"></script>

